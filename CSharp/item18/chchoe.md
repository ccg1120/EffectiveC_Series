# Effective c# 

# CHAPTER3 제네릭 활용

제네릭이 컬렉션과 함께 사용될 때만 유용한 것처럼 이야기 하곤 하지만 이는 사실이 아님.  
제네릭은 컬렉션 외에도 인터페이스, 이벤트 핸들러, 공통 알고리즘 구현 등 매우 다양한 분야에서 유용하게 활용 됨

타입을 제네릭으로 정의하면 장점도 있고 그에 따른 비용도 발생함.

제네릭을 사용하면 코드의 크기가 작아지지만 항상 그런것은 아님

**제네릭 사용 시 코드 크기를 결정하는 요인**
1. 타입 매개변수를 어떻게 지정하느냐
2. 얼마나 많은 수의 닫힌 제네릭 타입을 생성하느냐


**용어 정리**
- 자네릭 타입 정의 : 타입을 제네릭의 형태로 정의하는 경우
- 닫힌 제네릭 타입 : 타입 매개변수에 구체적인 타입을 지정한 경우
- 열린 제네릭 타입 : 일부만 구체적인 탕비을 지정한 경우

JIT 컴파일러는 닫힌 제네릭 타입으로 객체를 인스턴스화 하기 위한 코드를 생성할 때 비로소 타입의 정의를 완성  
(시간과 공간 비용을 고려한 절충안)

이런 과정은 제네릭의 사용 여부와 관계없이 우리가 정의한 모든 타입에 대해서도 동일하게 적용되는 과정

제네릭타입이 아니라면 클래스를 표현하는 IL과 이로부터 생성되는 머신 코드가 항상 일대일 관계를 유지하지만 제네릭을 사용하면  
해석 과정이 조금 다름

JIT컴파일러가 타입 매개변수로 주어진 타입을 확인하여 해당 타입에 가장 적합한 머신 코드를 생성하귀 위해 노력함

제네릭 타입의 타입 매개변수로 참조타입이 전달될 경우 항상 동일한 머신 코드가 생성되며 이를 공유하게됨


```c#
//아래 코드는 개별 인스턴스들을 런타입에 동일 머신 코드를 활용함
//왜? 참조형이라서 포인터 주소만 필요함

List<string> stringList = new List<string>();
List<Stream> streamList = new List<Stream>();
List<MyClassType> anotherList = new List<MyClassType>();
```
닫힌 제네릭 타입을 만들 때 타입 매개변수에 값 타입이 지정되면 참조 타입과는 다른 규칙이 적용됨  
서로 다른 머신 코드를 생성함

참조 타입이 주어지는 경우 어떤 타입이라도 메모리의 풋프린트에 전혀 영향을 주지 않음

```c#
//아래 코드는 전부 다른 머신 코드를 생성함
//타입 매개변수로 서로 다른 값 타입이 주어지는 경우 서로 다른 머신 코드가 생성되기 때문에 이는 공유 될수 없음
List<double> doubleList = new List<double>();
List<int> intList = new List<int>();
List<MyStruct> valutesList = new List<MyStruct>();
```

JIT 컴파일 할 때 타입 캐개변수에 값 타입이 지정되면 두 단계를 거치게 됨

1. 닫힌 제네릭 타입을 표한하기 위한 새로운 IL클래스를 생성하는것
2. 대체가 완료된 타입을 이용하여 실제로 머신 코드를 생성하는것

두단계가 필요한 이유는 어셈블리가 로도되는 시점에 JIT 컴파일러가 클래스의 머신 코드를 생헝하는 것이라 아니라, 특정 메서드가 최초로 호출되는 시점에 호출된 메서드만들 JIT 컴파일 하기 때문임  
이러한 과정은 제네릭 타입이 아닌 일반 타입의 경우도 동일함

타입별로 서로 다른 코드가 생성된다는 것은 런타임에 메모리의 풋프린트가 커진다는 사실을 의미함  
값 타입을 취하는 닫힌 제네릭 타입은 개별적인 IL코드를 가짐.

타입 매개변수로 지정한 값 타입의 유형에 따라 서로 다른 머신코드를 생성할 수밖에 없기 때문임  
하지만 제네릭 타입의 타입 매개변수로 값 타입을 지정하면 박싱과 언박싱을 피할 수 있고, 코드와 데이터의 크기가 줄어드는 장점이 있음.

컴파일러가 타입 안정성을 보장해주므로 런타입에 타입의 유형을 매번 확인할 필요가 없음. 따라서 코드의 크기가 줄고 성능이 개선됨

제네릭 클래스 대신 제네릭 메서드를 사용하면 실제로 사용되는 메서드만 인스턴스화되므로 추가되는 IL코드의 양이 많이 않음.

제네릭 메서드는 사전에 JIT컴파일 되지 않음.





# 아이템 18: 반드시 필요한 제약 조건만 설정하라

타입 매개변수에 대한 [제약 조건(Constraint)](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/where-generic-type-constraint)은 클래스가 작업을 올바르게 수행하기 위해 타입의 유형을 제한하는 방법

개발자는 회소한의 제약 조건만을 설정 해야하며 너무 많은 제약 조건을 설정하면 사용자들이 과도한 추가 작업을 수행해야 할 수도 있음 그래서 적절한 균형을 유지해야함

어떤 경우라도 극단적인 선택은 좋지 않음.

제약 조건을 설정하지 않으면 런타입에 더 많은 검사를 수행해야 하고 잘못된 타입으로 인해 런타임 오류가 발생할 가능성 도 있음

그래서 목표는 항상 중간 어디쯤을 찾아야함


제약 조건은 제네릭 타입에 대해 우리가 가정하고 있는 사실을 컴파일러와 다른 개발자에게 알려주는 용도로 사용됨

컴파일러 입장에서는 두가지 측면에서 도움이됨

1. 제네릭 타입을 작성 할때 도움이 됨
2. 제네릭 타입을 사용하는 사용자가 타입 매개변수로 올바른 타입을 지정했느지를 컴파일 타임에 확인 할 수 있음

제약 조건을 설정하는 대신 형변환이나 런타임에 테스트를 수행하도록 코드를 작성 할 수 있음

```c#
public static bool AreEqual<T>( T left, T right )
{
    if(left == null)
        return right == null;

    if(left is IComparable<T>)
    {
        IComparable<T> lval = left as IComparable<T>;
        if(right is IComparable<T>)
            return lval.CompareTo(right) == 0;
        else
            throw new ArgumentException("Type does not implement IComparable<T>", nameof(right));
    }
    else
    {
        throw new ArgumentException("Type does not implement IComparable<T>", nameof(left));
    }
}
//길다 길어
```

T가 반드시 IComparable<T>를 구현해야 한다고 제약 조건을 설정한다면??

```c#
public static bool AreEqual<T>( T left, T right )
{
    where T : IComparable<T> => left.CompareTo(right) == 0;
}
```

두번째 예와 같이 코드를 작성하면 런타임에 발생할 가능성이 있는 오류를 컴파일 타임에 확인 할 수 있음. 코드도 짧음

제네릭 타입을 작성할 때 필요한 제약 조건이 있다면 반드시 이를 지정하자.  
사용자가 제네릭 타입을 잘못 하용 하면 컴파일러가 이를 알려줄 수 있어 런타임 오류를 줄일 수 있고 오용 가능성도 낮출 수 있음

--------------------------
타입 매개변수에 제약 조건이 많으면 제네릭 타입을 사용 하는것이 큰 부담

C# 컴파일러는 제약 조건에 설정된 정보만을 이용하여 IL을 생성함. 인스턴스화 되었을 때 더 나은 메서드를 가졌다 하더라고 제네릭 타임을 컴파일할 때  
알려진 내용이 아니라면 사용하지 않음 (C#제네릭과 c++ 템플릿의 차이)

제약 조건을 설정할지의 여부를 어떤 기준으로 결정?  
일반적인 권고 사항은 IEquatable<T>와 같이 개선된 메서드를 사용하려고 시도해 보고 불가능한 경우라면 한 단계 낮은 수준의 메서드를 호출 하도록 코드를 작성하는것

클래스의 사용을 어렵게 만드느니 런타임에 특정 인터페이스를 구현하고 있는지 또는 특정 베이스 클래스를 상송한 타입인지 확인 한 후  
사용하는 것이 좋은 경우도 있음 (Equatable<T>와 Comparable<T>가 이런 식 으로 설계됨)

기본 생성자 제약 조건을 설정할 때는 추가적으로 주의해야 할 부분이 있음

참조 타입에 대해서는 default()와 new()가 매우 다른 의미를 가진다는 것에 주의해야함











