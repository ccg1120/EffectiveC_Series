# Effective c# 

# 아이템 12: 할당 구문보다 멤버 초기화 구문이 좋다.

클래스를 만들다 보면 둘 이상의 생성자를 작성 해야하는 경우가 발생   
이때 잘못하다 보면 초기화 누락이 일어 날 경우가 있음.

### **오류를 범하기 않기 위한 방법!**

생성자의 본문에서 멤버 변수에 값을 할당하기 보다 멤버 초기화 구문을 사용 할것!  
정적 변수와 인스턴스 변수 어느 쪽이라도 가능한 한 멤버 초기화 구문을 사용하는게 좋음

멤버 변수를 선언 할때 객체를 함께 생성하는 것 은  C#에서 매우 자연스러운 구문이므로 멤버 변수를 선언 할 때는 항상 초기화 구문을 사용하자

예시
```C#
public class MyClass
{
    private List<String> labels = new List<String>(); //초기화 구문!
}
```

MyClass타입에 몇 개의 생성자를 추가하든 멤버 변수를 초기화 할 수 있음  

컴파일러는 모든 생성자의 시작 부분에 멤버 초기화 구문을 포함 시키기 때문에 새로운 생성자를 추가하더라도 멤버 초기화 구문이 항상 포함이 됨.  
따라서 생성자의 본문에서 별도로 멤버 변수를 초기화 하지 않아도 됨  

멤버 초기화 구문은 초기화 작업 그 이상의 역할도 함

멤버 초기화 구문에 의해 생성된 코드는 생정자 본문의 앞쪽에 덧붙여짐(베이스 클래스의 생성자 보다 먼저 초기화가 이뤄짐)  

### **알아두면 좋은거**
멤버 변수의 초기화 순서는 변수의 선언 순서대로 수행된다는 점

### **멤버 초기화 구문 사용에 주의해야 할 때**
1. 객체를 0이나 null로 초기화하는 경우
2. 동일한 객체를 반복해서 초기화하는 경우
3. 예외 처리가 반드시 필요한 경우

이유를 알아보자

## 1.객체를 0이나 null로 초기화하는 경우 

기본 시스템 초기화 루틴은 코드를 실행 하기 전에 모든 값을 0으로 설정함
시스템 초기화 루틴은 저수준 CPU명령을 수행하여  
메모리 블록을 0으로 설정함 따라서 0이나 null로 초기화 할 필요가 없음  

따로 설정 했다면 **괜한 일을 추가적으로 하는 꼴** 그래서 주의 필요

```c#
MyValType myVal1; // 시스템에 의해 0으로 초기화
MyValType myVal2; = new MyValType(); //반복해서 0으로 초기화
```

위 예제는 모두 0으로 변수를 초기화함

두번째 문장은 initobj라는 IL 명령을 사용하여 초기화가 되는데 박싱/언박싱된 myVal2변수 모두에 대해서 0으로 초기화하는 과정이 수행됨  
이 과정으로 약간의 추가 시간이 소요됨 **(아이템9: 박싱과 언박싱을 최소화하라)**

## 2.동일한 객체를 반복해서 초기화하는 경우

멤버 초기화 구문은 객체 생성 방법이 모든 생성자에서 동일한 경우에만 사용하는 것이 좋음

```c#
public class MyClass2
{
    private List<String> labels = new List<String>(); // 생성자 호출 전에 먼저 생성됨

    MyClass2()
    {}

    MyClass2(int size)
    {
        labels = new new List<String>(size); // 멤버 초기화 구문과 다른 방식의 초기화를 사용함
        //생성자 호출 되면서 새롭게 생성하기 때문에 멤버 초기화 구문에서 생성된 객체는 바로 가비지 ㅂㅂ
    }
}
```

위 코드는 실제로 2개의 List<>객체가 생성되며 그중 하나는 즉각 가비지가 됨  
멤버 초기화 구문은 생성자의 본문보다 앞서 수행 되므로 생성자 본문에서 생성한 객체만 살아 남음  

```c# 
//위 예시는 이런 느낌으로 작성된 코드임
public class MyClass2
{
    private List<String> labels;

    MyClass2()
    {
        private List<String> labels = new List<String>();
    }

    MyClass2(int size)
    {   
        labels = new List<String>(); // 불필요 !!
        labels = new new List<String>(size); 
    }
}
```

불필요한 코드가 포함된 꼴이 됨, 주의 필요

## 3.예외 처리가 반드시 필요한 경우

멤버 초기화 구문은 try를 감쌀 수 없기 때문에 초기화 과정에서 예외가 발생하면 예외가 외부로 전파 됨  
따라서 클래스 내부에서 복구를 시도 할 수 없음  
예외처리가 필요한 경우 생성자를 만들고 생성자 내부로 초기화 코드를 옮기고 예외처리 코드를 적절히 구현 해야함(아이템47: 사용자 지정 예외 클래스를 완벽하게 작성하라 참조)


# 마무리

멤버 초기화 구문을 이용하면 생성자가 여러 개 일 때도 멤버 변수 초기화를 누락하지 않도록 도와줌

다만, **모든 생성자가 동일한 방법으로 멤버 변수를 초기화 하는 경우에 한해서만 이 방법을 사용**해야 함


[CS0165](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/compiler-messages/cs0165) 컴파일 오류 초기화되지 않은 변수를 사용했을때 

초기화를 안한 경우 컴파일 오류를 발생 시키는게 있나 했는데 없는걸로 보임






